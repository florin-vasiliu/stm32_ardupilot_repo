/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define ALIAS_BASE 0x22000000U
#define BITBAND_BASE 0x20000000U

#define SRAM_START 0x20000000U
#define SRAM_SIZE  (128U * 1024U) //128KB
#define SRAM_END   ((SRAM_START) + (SRAM_SIZE))
#define STACK_START   SRAM_END

#define STACK_MSP_START STACK_START
#define STACK_MSP_END   (STACK_MSP_START - 512)
#define STACK_PSP_START STACK_MSP_END

#define USART3_IRQNO 39

#define SIZE_TASK_STACK 1024U
#define SIZE_SCHED_STACK 1024U
#define T1_STACK_START SRAM_END
#define T2_STACK_START (T1_STACK_START - SIZE_TASK_STACK)
#define T3_STACK_START (T2_STACK_START - SIZE_TASK_STACK)
#define T4_STACK_START (T3_STACK_START - SIZE_TASK_STACK)
#define SCHED_STACK_START (T4_STACK_START - SIZE_TASK_STACK)

#define TICK_HZ 1000U
#define HSI_CLOCK 16000000U
#define SYSTICK_TIM_CLK HSI_CLOCK

__attribute__((naked)) void change_sp_to_psp(void)
{
	__asm volatile(".equ SRAM_END, (0x20000000U + 128U * 1024U)");
	__asm volatile (".equ PSP_START, (SRAM_END - 512)");

	//Load psp stack pointer into the PSP register
	__asm volatile ("LDR R0, =PSP_START");
	__asm volatile ("MSR PSP, R0");

	//Set bit 1 to select PSP in CONTROL register
	__asm volatile("MOV  R0,#0X02");
	__asm volatile("MSR  CONTROL, R0");

	//Return from function
	__asm volatile ("BX LR");
}

/* This function executes in THREAD MODE of the processor */
void generate_interrupt()
{
	uint32_t *pSTIR = (uint32_t*)0xE000EF00;
	uint32_t *pISER0 = (uint32_t*)0xE000E100;

	/* enable IRQ3 interrupt */
	*pISER0 |= (1 << 3);

	/* generate an interrupt from software for IRQ3 */
	*pSTIR = (3 & 0x1FF);
}

void change_access_level_unpriv(void){
	//Read
	__asm volatile ("MRS R0, CONTROL"); /* copy the value of the CONTROL special register into R0 */
	//Modify
	__asm volatile ("ORR R0, R0,#0x01"); /* change the privileged value to unprivileged */
	//Write
	__asm volatile ("MSR CONTROL, R0");
}

void init_systick_timer(uint32_t tick_hz){
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;
	uint32_t count_value = (SYSTICK_TIM_CLK / tick_hz) - 1;
	// clear the value of SVR
	*pSRVR &= ~(0x00FFFFFF);
	// load the count value
	*pSRVR |= count_value;

	__asm volatile ("CPSIE i"); //enable global interrupts

	// enable the systick timer and select processor clock and enable interrupt
	*pSCSR |= (1 << 2); // enable interrupt
	*pSCSR |= (1 << 1); // select processor clock
	*pSCSR |= (1 << 0); // enable systick timer
}

// Creating 4 tasks
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
void SysTick_Handler(void);

int main(void)
{
	/* Create round robin scheuler */

	init_systick_timer(TICK_HZ);

	/* Demonstrate the generation of an interrupt */
	// 1. First configure USART3 peripheral (missing in current code)
	// Configure USART3 here...

	// 2. Configure NVIC with proper priority
	uint32_t *pIPR5 = (uint32_t*)(0xE000E400 + (USART3_IRQNO / 4));
	*pIPR5 &= ~(0xFF << ((USART3_IRQNO % 4) * 8));  // Clear priority
	*pIPR5 |= (0x50 << ((USART3_IRQNO % 4) * 8));   // Set priority to mid-range (0x50)

	// 3. Enable the specific interrupt
	uint32_t *pISER1 = (uint32_t*)0xE000E104;
	*pISER1 |= (1 << 7);

	// 4. Enable global interrupts
	__asm volatile ("CPSIE i");

	// 5. Now set the pending bit to trigger the interrupt
	uint32_t *pISPR1 = (uint32_t*)0xE000E204;
	*pISPR1 |= (1 << 7);


	/* Demonstrate changing stack pointer from main to psp */
	//change_sp_to_psp();

	/* Demonstrate bit-banding */
	uint8_t *ptr = (uint8_t*)0x20000200; //some address in SRAM
	*ptr = 0xff;
	//normal method
	*ptr &= ~(1 << 7); //clear bit 7
	//reset to 0xff
	*ptr = 0xff;
	//bit-banding method
	uint8_t *bitband_addr = (uint8_t*) (ALIAS_BASE + (32 * (0x20000200 - BITBAND_BASE)) + (7 * 4));
	*bitband_addr = 0; //clear bit 7

	/* Demonstrate inline assembly coding */
	__asm volatile ("LDR R1, =#0X20001000");
	__asm volatile ("LDR R2, =#0X20001004");
	__asm volatile ("LDR R0, [R1]");
	__asm volatile ("LDR R1, [R2]");
	__asm volatile ("ADD R0, R0, R1");
	__asm volatile ("STR R0, [R2]");

	int val1=50;
	int val2 = 10;
	__asm volatile ("ADD R0, %0, %1": :"r"(val1),"r"(val2));

	/* using special registers */
	/* read CONTROL special register */
	int control_reg;
	__asm volatile ("MRS %0, CONTROL": "=r"(control_reg) );



	/* print line on SVC
	while(1){
	printf("Hello World!\n");
	};
	*/

	/* Changing privilege access level */
	/* change_access_level_unpriv(); */

	/* demonstrate interrupt mode */
	printf("In thread mode : before interrupt\n");
	generate_interrupt();
	printf("In thread mode : after interrupt\n");


	/* Loop forever */
	for(;;);
}

void RTC_WKUP_IRQHandler(void)
{
	printf("in handler mode : ISR\n");
}

void HardFault_Handler(void)
/* function created to demonstrate failure to modify system level registers (interrupt handler) in unprivileged access mode*/
{
	printf("in HardFault detected\n");
	while(1);
}

void USART3_IRQHandler(void)
{
	printf("In USART3 isr\n");
}

void task1_handler(void)
{
	while(1)
	{
		printf("I am task 1\n");
	}
}

void task2_handler(void)
{
	while(1)
	{
		printf("I am task 2\n");
	}
}

void task3_handler(void)
{
	while(1)
	{
		printf("I am task 3\n");
	}
}

void task4_handler(void)
{
	while(1)
	{
		printf("I am task 4\n");
	}
}

void SysTick_Handler(void)
{
	//Scheduler code to be added here
}
