/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define ALIAS_BASE 0x22000000U
#define BITBAND_BASE 0x20000000U

#define SRAM_START 0x20000000U
#define SRAM_SIZE  (128U * 1024U) //128KB
#define SRAM_END   ((SRAM_START) + (SRAM_SIZE))
#define STACK_START   SRAM_END

#define STACK_MSP_START STACK_START
#define STACK_MSP_END   (STACK_MSP_START - 512)
#define STACK_PSP_START STACK_MSP_END

__attribute__((naked)) void change_sp_to_psp(void)
{
	__asm volatile(".equ SRAM_END, (0x20000000U + 128U * 1024U)");
	__asm volatile (".equ PSP_START");

	//Load psp stack pointer into the PSP register
	__asm volatile ("LDR R0, =STACK_PSP_START");
	__asm volatile ("MSR PSP, R0");

	//Set bit 1 to select PSP in CONTROL register
	__asm volatile("MOV  R0,#0X02"); 
	__asm volatile("MSR  CONTROL, R0");

	//Return from function
	__asm volatile ("BX LR");
}	

/* This function executes in THREAD MODE of the processor */
void generate_interrupt()
{
	uint32_t *pSTIR = (uint32_t*)0xE000EF00;
	uint32_t *pISER0 = (uint32_t*)0xE000E100;

	/* enable IRQ3 interrupt */
	*pISER0 |= (1 << 3);

	/* generate an interrupt from software for IRQ3 */
	*pSTIR = (3 & 0x1FF);
}

void change_access_level_unpriv(void){
	//Read
	__asm volatile ("MRS R0, CONTROL"); /* copy the value of the CONTROL special register into R0 */
	//Modify
	__asm volatile ("ORR R0, R0,#0x01"); /* change the privileged value to unprivileged */
	//Write
	__asm volatile ("MSR CONTROL, R0");
}


int main(void)
{
	/* Demonstrate changing stack pointer from main to psp */
	change_sp_to_psp();

	/* Demonstrate bit-banding */
	uint8_t *ptr = (uint8_t*)0x20000200; //some address in SRAM
	*ptr = 0xff;
	//normal method
	*ptr &= ~(1 << 7); //clear bit 7
	//reset to 0xff
	*ptr = 0xff;
	//bit-banding method
	uint8_t *bitband_addr = (uint8_t*) (ALIAS_BASE + (32 * (0x20000200 - BITBAND_BASE)) + (7 * 4));
	*bitband_addr = 0; //clear bit 7

	/* Demonstrate inline assembly coding */
	__asm volatile ("LDR R1, =#0X20001000");
	__asm volatile ("LDR R2, =#0X20001004");
	__asm volatile ("LDR R0, [R1]");
	__asm volatile ("LDR R1, [R2]");
	__asm volatile ("ADD R0, R0, R1");
	__asm volatile ("STR R0, [R2]");

	int val1=50;
	int val2 = 10;
	__asm volatile ("ADD R0, %0, %1": :"r"(val1),"r"(val2));

	/* using special registers */
	/* read CONTROL special register */
	int control_reg;
	__asm volatile ("MRS %0, CONTROL": "=r"(control_reg) );



	/* print line on SVC
	while(1){
	printf("Hello World!\n");
	};
	*/

	/* Changing privilege access level */
	/* change_access_level_unpriv(); */

	/* demonstrate interrupt mode */
	
	printf("In thread mode : before interrupt\n");

	generate_interrupt();

	printf("In thread mode : after interrupt\n");
	

	/* Loop forever */
	for(;;);
}

void RTC_WKUP_IRQHandler(void)
{
	printf("in handler mode : ISR\n");
}

void HardFault_Handler(void)
/* function created to demonstrate failure to modify system level registers (interrupt handler) in unprivileged access mode*/
{
	printf("in HardFault detected\n");
	while(1);
}
